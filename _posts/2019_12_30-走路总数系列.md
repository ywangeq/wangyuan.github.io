---
layout:     post
title:      Leecode
subtitle:   medium-不同路径系列
date:       2019-12-30
author:     WY
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - Leecode_medium
    - 动态规划
    - python
---

> 题目： m x n的网格从左上角走到右下角的总共不同路径
- 最基本的左上到右下
- 有障碍
- follow up- 类似走迷宫，给定起点和终点
- follow up 带权重
- follow up 带权重 且走两回

**case 1** 
数塔问题
考虑是不带权重的简单走路方式统计，我们直接简单的dp
当前状态等于 上面状态+左边状态

```
def s(m,n):
    dp =[[0 for i in range(n)] for j in range(m)]
    for i in range(m):
        for j in range(n):
            if i==0 or j==0:
                dp[i][j]=1
            else:
                dp[i][j]=dp[i-1][j]+dp[i][j-1]
    return dp[-1][-1]
```

**case 2**
> 有障碍 grid
```
def s(grid):
    m =len(grid)
    n = len(gird[0])

    dp =[[0 for i in range(n)] for j in range(m)]
    dp[0][0]=1

    for i in range(m):
        for j in range(n):
            if grid[i][j]==1:
                dp[i][j]=0
            else:
                if i!=0:
                    dp[i][j]+= dp[i-1][j]
                if j!=0:
                    dp[i][j]+=dp[i][j-1]
    return dp[-1][-1]
```

**case 3**
> 变题 不再是单纯的左上角到右下角，并且可以上下左右走动
题目具体要求：
-  1 表示起始方格，有且仅有一个
-  2 表示结束方格
-  0 表示我们可一个的空方格
- -1 表示我们无法跨越的
要求走过所有无障碍方格
> 依旧是动态规划，添加记忆化状态来避免答案重复搜索








**case 4**
带权重的走（最大/最小路径和）
> 基本的动态规划，dp(i,j)=grid(i,j)+min(dp(i-1,j),dp(i,j-1))
> 最大 的解法类似
```
def minPath(grid):
    m = len(grid[0])
    n = len(grid)
    dp =[[0 for i in range(m)] for j in range(n)]

    dp[0][0]=grid[0][0]
    for i in range(1,m):
        dp[0][i]=grid[0][i]+dp[0][i-1]
    for i in range(1,n):
        dp[i][0] = grid[i][0]+dp[i-1][0]
    for i in range(1,n):
        for j in range(1,m):
            dp[i][j] = min(dp[i-1][j],dp[i][j-1])+grid[i][j]
    return dp[-1][-1]
```

**case 5**
>带权重走，左上到右下 再回去， 双线程dp，不可以用贪心!
> 该问题考虑成两个人同时从左上往右下
```
def double(self,grid):
    if not grid: return 0
    self.grid = grid
    self.mem={}
    self.N = len(grid)
    self.M = len(grid[0])
    return max(self.dp(0,0,0,0),0)
def dp(self,x1,y1,x2,y2):
    if (x1,y1,x2,y2) in self.mem: return self.mem[(x1,y1,x2,y2)]
    N = self.N
    M = self.M
    if x1==N or y1==M or x2==N or y2==ML
        return -1
    if x1==N-1 and y1==M-1 and i2==N-1 and j2==M-1:
        return self.grid[x1][y1]
    dd =self.dp(x1+1,y1,x2+1,y2)
    dr =self.dp(x1+1,y1,x2,y2+1)
    rd =self.dp(x1,y1+1,x2+1,y2)
    rr =self.dp(x1,y+1,x2,y2+1)
    maxC = max([dd,dr,rd,rr])
    if x1==x2 and y1==y2:
        out = maxC + self.grid[x1][y1]
    else:
        out = maxC + self.grid[x1][y1]+self.grid[x2][y2]

    self.mem[(x1,y1,x2,y2)]=out
    return out
```