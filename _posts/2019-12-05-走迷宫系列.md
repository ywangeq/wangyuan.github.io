---
layout:     post
title:      Leecode 499
subtitle:   走迷宫
date:       2019-12-08
author:     WY
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - Leecode_medium
    - dfs
    - python
---

- 走迷宫1
- 迷宫2
- 迷宫3 hard
- 逃离大迷宫 1036

> 迷宫1 
> 由空地和墙组成的迷宫中有一个球。球可以向上下左右四个方向滚动，但在遇到墙壁前不会停止滚动。当球停下时，可以选择下一个方向。给定球的起始位置，目的地和迷宫，判断球能否在目的地停下。

- 思路 dfs 搜索 再注意过程中剪枝

```
def hasPath(maze,start,end):
    m , n = len(maze),len(maze[0])
    direction = [(0,1),(0,-1),(1,0),(-1,0)]
    def dfs(maze,x,y,end):
        maze[x][y]=-1 #记忆化防止重复走
        if x==end[0] and y==end[1]: return True
        res =False
        i,j = x,y
        for dx,dy in direction:
            x,y=i,j
            while 0<=x+dx<m and 0<=y+dy<n and (maze[x+dx][y+dy]==0 or maze[x+dx][y+dy]==-1):
                x = dx+x
                y = dy+y
            if maze[dx+x][dy+y]!=-1:
                res = res or dfs(maze,x,y,end)

        return res
    return dfs(maze,start[0],start[1],end)
```

> 迷宫2， 是找出start to end 的最短距离
- BFS 会方便一些，方法类似
```
def shortdis(maze,start,end):
    direction= ....
    import heapq # 建立一个堆
    m,n = len(maze),len(maze[0])
    start,end = tuple(start),tuple(end)
    stack = [(0,start)]
    visited=set()#防止重复
    while stack:
        path,cur = heapq.heappop(stack)
        if cur == end:
            return path
        visited.add(cur)
        for dx,dy in direction:
            x,y=cur
            l =0
            while 0<=x+dx<m and 0<=y+dy<n and maze[dx+x][dy+y]==0:
                x,y=dx+x,dy+y
                l+=1
                if (x,y) not in visited:
                    heapq.heappush(stack,(path+l,(x,y)))
    return -1
``` 

由空地和墙组成的迷宫中有一个球。球可以向上（u）下（d）左（l）右（r）四个方向滚动，但在遇到墙壁前不会停止滚动。当球停下时，可以选择下一个方向。迷宫中还有一个洞，当球运动经过洞时，就会掉进洞里。

给定球的起始位置，目的地和迷宫，找出让球以最短距离掉进洞里的路径。 距离的定义是球从起始位置（不包括）到目的地（包括）经过的空地个数。通过'u', 'd', 'l' 和 'r'输出球的移动方向。 由于可能有多条最短路径， 请输出字典序最小的路径。如果球无法进入洞，输出"impossible"。

迷宫由一个0和1的二维数组表示。 1表示墙壁，0表示空地。你可以假定迷宫的边缘都是墙壁。起始位置和目的地的坐标通过行号和列号给出。
- hard 问题 主要要考虑维护两个记忆体
- 本质思想差不多，这种要找路的过程的，最好用BFS

```
def findshort(maze,ball,hole):
    directions = [(-1,0,'u'),(0,1,'r'),(0,-1,'l'),(1,0,'d')]   
    m,n = len(maze),len(maze[0])
    stack =[(ball[0],ball[1])]
    distance=[[float('inf')]*n for _ in range(m)]
    string = [['imposs']*n for _ in range(m)]
    # 构造队列，并将起始位置包含其中
    # distance 保存从起点到每个点的距离
    # string 保存每个点对应的字符串


    distance[ball[0],ball[1]]=0
    string[ball[0],ball[1]]=''
    while stack:
        i,j = stack.pop(0)
        for dx,dy,di in directions:
            x,y,step,word = i+dx,j+dy,distance[i][j],string[i][j]
            while 0<=x<m and 0<=y<n and maze[x][y] == 0 and (x-dx!=hole[0] or y-dy!=hole[1]):  # 当x,y坐标合法，并且对应值为0，且没有越过hole
                x=dx+x
                y=dy+y

                step+=1
            x = x-dx
            y = y-dy
            if distance[x][y] > step or (distance[x][y]==step and word+letter<string[x][y]):    # 如果起点到该点的距离比当前距离大
            # 或者相等，但是字符串的字典序大
            # 更新该距离和字符串，并将坐标加入队列
                    distance[x][y] = step
                    string[x][y] = word+di
                    if x!=hole[0] or y!=hole[1]:    # 当坐标不是hole坐标时
                        stack.append((x,y))         # 将其添加到队列中
                                           
    return string[hole[0]][hole[1]]



```

在一个 10^6 x 10^6 的网格中，每个网格块的坐标为 (x, y)，其中 0 <= x, y < 10^6。

我们从源方格 source 开始出发，意图赶往目标方格 target。每次移动，我们都可以走到网格中在四个方向上相邻的方格，只要该方格不在给出的封锁列表 blocked 上。

只有在可以通过一系列的移动到达目标方格时才返回 true。否则，返回 false。

输入：blocked = [[0,1],[1,0]], source = [0,0], target = [0,2]
输出：false
解释：
从源方格无法到达目标方格，因为我们无法在网格中移动。

- 本质上是个dfs的过程，但是关键一点是如何判断 可以走到，由于棋盘很大，不能真的做完全dfs，因此要在block上思考
- 得出 如果能够走出的step>(len(block)*(len(block)-1))则说明我们一定走的到target， 双向检测

```
def ispathPossible(blocked,source,target):
    if not blocked: return True
    block = set([(x,y) for x,y in blocked]) #优化空间
    step=1
    source_to_target =self.dfs(source,blocked,step,target)
    target_to_source = self.dfs(target,blocked,step,source)
    return sour


```