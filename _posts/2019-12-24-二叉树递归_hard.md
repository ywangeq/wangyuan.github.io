---
layout:     post
title:      Leecode
subtitle:   二叉树-hard
date:       2019-12-24
author:     WY
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - Leecode_hard
    - 递归
    - tree(bs)
    - python
---

> 二叉树最大路径和系列
- 满足root-->leaf
- 任意起点


**case 1** 
> 要求返回最大和以及path

```
class TreeNode:
    def __init__(self,val):
        self.val = val
        self.left = None
        self.right=None
path =[]
def maxsum(root):
    if not root: return
    max_l = 0 if not root.left else maxsum(root.left)
    max_r = 0 if not root.right else maxsum(root.right)

    return root.val+max(max_l,max_r)
def maxsumPath(root,sum):
    if sum==0:
        return True
    if root is None:
        return False
    left = maxsumPath(root.left,sum-root.val)
    right =maxsumPath(root.right,sum-root.val)
    if left or right:
        path.append(root.val)
    return left or right
    
def main(root):
    max_S = maxsum(root)
    path =maxsumPath(root,max_S)
    return max_S,path[::-1]
```

**case 2** 
#### 任意起点

```
class Solution:
    def maxPathSum(self, root: TreeNode) -> int:
        self.max = float('-inf')
        self.path=[]
        self.te=[]
        self.max_path(root)
        print(self.path,'df',self.te)
        return self.max
        
    def max_path(self, root):
        if not root: return 0
        left = self.max_path(root.left)
        right = self.max_path(root.right)
        self.max = max(left + right + root.val, self.max)
        tmp = max(left, right) + root.val
        return tmp if tmp > 0 else 0
```

> 返回路径 暂时不会